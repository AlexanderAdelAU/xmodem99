
;
;****************************************
;
;	NAME XMODEM
;	PURPOSE : TO TRANSFER FILES BETWEEN MACHINES
;	USING THE XMODEM PROTOCOL.  WRITTEN BY ALEXANDER CAMERON
;	VERSION 1.3	14TH MAY 2020 - DURING THE COVID-19 PANDEMIC IN ADELAIDE
;	VERSION 1.4	24TH MAY 2020 - ADDED SECTOR BY SECTOR DIRECT WRITING TO DISC
;
;	USAGE:  XMODEM <FILENAME> {NO OPTION LIST AT PRESENT}
;
;
; -------- 3. MESSAGE BLOCK LEVEL PROTOCOL

;Link to this description;  http://textfiles.com/programming/ymodem.txt
;
; Each block of the transfer looks like:
; <SOH><blk #><255-blk #><--128 data bytes--><cksum>
;    in which:
;
; <SOH>       = 01 hex
; <blk #>     = binary number, starts at 01 increments by 1, and
;               wraps 0FFH to 00H (not to 01)
; <255-blk #> = blk # after going thru 8080 "CMA" instr.
;               Formally, this is the "ones complement".
; <cksum>     = the sum of the data bytes only.  Toss any carry.
;
;
;  SENDER                           RECEIVER
;                                   Times out after 10 seconds,
;                           <---    <nak>
;  <soh> 01 FE -data- <xx>   --->
;                           <---    <ack>
;  <soh> 02 FD -data- <xx>   --->   (data gets line hit)
;                           <---    <nak>
;  <soh> 02 FD -data- <xx>   --->
;                           <---    <ack>
;  <soh> 03 FC -data- <xx>   --->   (ack gets garbaged)    <---    <ack>
;  <soh> 03 FC -data- <xx>   --->
;                           <---    <ack>
;  <eot>                     --->
;                           <---    <ack>
;
;
;**************************************
;
; THESE XOP ARE DEFINED IN THE MONITOR.   
; NOTE XOP WORSPACES ARE OVERLAPPED 
; SO THAT ALL REGISTERS R0 TO R7 ARE SHARED.
;
;
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8
	DXOP	POP,9
	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12		;WRITE CHAR IN MSB
	DXOP	READ,13		;READ CHAR IN MSB
	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
SL	EQU	9
SP	EQU	10
R11	EQU	11
R12	EQU	12
R13	EQU	13
R14	EQU	14
R15	EQU	15
;
;
;	BDOS EQUATES	
;
TPA	EQU	0100H		;DEFAULT START ADDRESS
BDOS	EQU	84H		;BDOS VECTORS.
SHELL	EQU	80H		;SHELL VECTOR
CMDLINE	EQU	0A0H		;SHELL COMMAND LINE POINTER

NAMSIZ	EQU	11		;DIRECTORY NAME SIZE
SELDSK	EQU	14
OPEN	EQU	15
FCLOSE	EQU	16
ERAFIL	EQU	19
MAKFIL	EQU	22
WRSEQ	EQU	21
SETDMA	EQU	26
;
;---FCB	EQUATES
;
NAM	EQU	0
FTY	EQU	11
FLA	EQU	16
FSB	EQU	12
FSZ	EQU	14
CRN	EQU	26
;
;
	AORG	0100H
	JMP	START
;
;	MISC DEFINITIONS
;
SPACE	BYTE	20H
SWITCH	BYTE	'-'		;COMMAND LINE SWITCH
BYTSEC	EQU	512
RECSIZE 	EQU	128
REC_COUNT	WORD	4		;THIS ASSUME 4 128 BYTE RECORDS PER BLOCK
;
;
CMD_ERROR:	B	@CMDERR

START:	LWPI	WORKSP
	LI	SP,STACKP
	MESG	@VERSION
	MESG	@CRLF
	MOV	@CMDLINE,R4		;GET CMD BUFFER POINTER
START01
	CB	*R4+,@SPACE	 	;LOOK FOR SPACES BETWEEN COMMAND ARGS
	JL	CMD_ERROR
	JNE	START01
	DEC	R4	 	;BACK UP TO 1ST CHAR
START02
	CB	*R4+,@SPACE		;NOW JUMP OVER SPACES
	JLE	START02
	DEC	R4
	MOV	R4,@LINPTR
	MOV	R4,R3		;R3->NAME
	LI	R0,NAMSIZ 		;FCB COUNTER
	LI	R8,FCB	  	;
	MOV	R8,R2	 	;SAVE FCB
NAM0	CB	*R3,@SPACE	 	;END OF NAME ?
	JLE	NAM4	 	;YES
	MOVB	*R3+,*R2+		;STORE IN FCB
	DEC	R0
	JNE	NAM0
	JMP	GOT_NAME
NAM4	MOVB	@SPACE,*R2+	 	;PAD WITH SPACES
	DEC	R0
	JNE	NAM4
;
; CREATE THE NAMED FILE
;
GOT_NAME:	LI	R2,SELDSK
	CLR	R3
	CALL	@BDOS		;SELECT DRIVE A
	LI	R2,ERAFIL 		;PURGE IF ALREADY EXITS
	LI	R3,FCB
	CALL	@BDOS
	LI	R2,MAKFIL
	LI	R3,FCB
	CALL	@BDOS	 	;TRY TO MAKE THE FILE
	MOV	R1,R1	 	;SUCCESS ?
	JLT	MKERR	 	;MAKE ERROR
	CLR	R0
	LI	R3,FCB
	MOVB	R0,@FTY(R3)		;ZERO SAYS DONT CARE
	MOV	R0,@CRN(R3)		;BEGIN AT FIRST RECORD
	LI	R0,TPA		;ASSUME TPA
	MOV	R0,@FLA(R3)		;INTO LOAD ADDRESS
;
;	BEGIN RECEIVING THE FILE BY LOADING INTO THE BUFFER
;	WRITE SECTOR BY SECTOR TO DISC
;
	CALL	@RECV_FILE		;RECEIVE THE FILE AND WRITE IT SECTOR BY SECTOR
	CALL	@CLOSE_FILE
	B	@EXIT
;
;=======================================================
;
;	ERROR CREATING FILE, SHOW MESSAGE THEN EXIT
;
;=======================================================
MKERR:	LI	R0,MAKMSG
	B	@LOAD_END

;
;  TERMINATE THE PROCESS
;
CMDERR:	LI	R0,CMDMSG
	MESG	@CMDMSG
	B	@LOAD_END
;
;=======================================================
;
;	CLOSE THE FILE, IF SECTOR BUFFER HAS RECEIVED DATA
;	THEN FLUSH WITH A CALL TO wRITE_SECTOR
;
;=======================================================
CLOSE_FILE:
	MOV	@REC_COUNT,R0
	JEQ	CLS_1
	CALL	@WRITE_SECTOR	;FLUSH AND WRITE ALL

CLS_1:	LI	R2,FCLOSE	 	;NOW CLOSE THE FILE
	LI	R3,FCB
	CALL	@BDOS
	RET
;
EXIT:	CLR	R1		;RETURN CODE FOR SHELL
	B	@SHELL		;NEED TO CALL SHELL INIT BECAUSE WE HAVE ALTERED WP
;
;****************************************************************************
;
; WRITE 2 SECTOR'S WORTH OF DATA I.E. BASED ON 512 BYTE SECTORS ON THE DISC
;
;*****************************************************************************
;
WRITE_SECTOR:
	LI	R2,SELDSK
	CLR	R3
	CALL	@BDOS
	LI	R3,SECTOR_BUFFER
	LI	R2,SETDMA
	CALL	@BDOS
	LI	R2,WRSEQ
	LI	R3,FCB
	CALL	@BDOS
	MOV	R1,R1	 		;WRITE ERROR ?
	JLT	WS_E	 		;YES
	RET
WS_E:	B	@WRITE_ERROR
;	
;
; ERROR MESSAGE AND HANDLING
;
CRLF	BYTE	0DH,0AH,0
	EVEN
CMDMSG	TEXT	"** COMMAND LINE ERROR **"
	BYTE	0DH,0AH,0
	EVEN


MAKMSG	TEXT	"** FILE CREATE ERROR **"
	BYTE	0DH,0AH,0
	EVEN
WRITE_MESSAGE
	TEXT	"** OUTPUT FILE WRITE ERROR **"
	BYTE	0DH,0AH,0
	EVEN
MDMMSG  	BYTE	0DH,0AH
	TEXT	"** FATAL LOAD ERROR **"
	BYTE	0
	EVEN
SECT_ERROR_MSG
	BYTE	0DH,0AH
	TEXT	"** RECEIVE SECTOR ERROR **"
	BYTE	0DH,0AH,0
	EVEN

SEQ_ERROR_MSG
	BYTE    0DH,0AH
	TEXT	"** SECTOR OUT OF SEQUENCE ERROR **"
	BYTE	0DH,0AH,0
	EVEN
END_MESSAGE
	TEXT	"LOAD_END"
	BYTE	0DH,0AH,0
	EVEN
VERSION	TEXT	"MODEM VERSION 1.5 - READY."
	BYTE	0DH,0AH,0
	EVEN
SAVING	TEXT	"SAVING FILE.."
	BYTE	0DH,0AH,0
	EVEN
CLOSE_MESSAGE
	TEXT	"***ERROR CLOSING FILE ***"
	BYTE	0DH,0AH,0
	EVEN
LARGE_FILE_MSG
	TEXT	"***ERROR CLOSING FILE ***"
	BYTE	0DH,0AH,0
	EVEN
ERR_MSG_ADDR
        WORD    0   ;ADDRESS OF MESSAGE TO BE OUTPUT



;CLOSERR	MESG	@CLOSE_MESSAGE		;IF WE DONT CLOSE UNUSED BLOCKS MAY
;	JMP	MKERR			;BE STILL ALLOCATED	
;LARGERR	MESG	@LARGE_FILE_MSG
;	JMP	MKERR
	
;
;	
;  LOAD THE RECIEVED FILE OR MODULE INTO MEMDORY
;
NAK		BYTE	15H
ACK		BYTE	06H
SOH		BYTE	01H
EOT		BYTE	04H
ETB		BYTE	017H
CAN		BYTE	018H
NULL		BYTE	000H
RECVD_SECT_NO	BYTE	0		;RECEIVED RECORD NUMBER	
COMP_REC_NO		BYTE	0		;INVERED NUMBER OF RECEIVED RECORD NUMBER
SECTNO		BYTE	0		;PREVIOUS RECEIVED RECORD NUMBER
CHECKSUM		BYTE	0
REC_TIME_OUT	BYTE	0FFH
		EVEN
;
RECV_FILE:
	LI	R4,SECTOR_BUFFER
	CLR	R0
	MOV	R0,@SECTNO		; MUST BEGIN THIS AT ZERO 
;
;
; THIS IS THE MAIN RECEIVE LOOP
;

RECV_LOOP:
	LI	R0,16		;RETRY COUNTER
	MOV	R0,@RETRY

RECV_HDR:
	LI	R1,64
	CALL	@RECV_WAIT		;LOOP UNTIL SENDER DONE BEFORE SENDING NAK
	CB	R2,@REC_TIME_OUT	;TIMEOUT ERROR ?
	JNE	RHNTO		;NO TIMEOUT,

RECV_SECT_ERR:
	LI	R1,16
	CALL	@RECV_WAIT		;LOOP UNTIL SENDER DONE BEFORE SENDING NAK
	CB	R2,@REC_TIME_OUT	;TIMEOUT ERROR ?
	JNE	RECV_SECT_ERR	;NO, THEN STILL STUFF ARRIVING
	DEC	@RETRY
	JEQ	SECTOR_ERROR 	;FORCE AND END
	MOVB	@NAK,R2
	CALL	@TX
	JMP	RECV_HDR
;
; GOT CHAR MUST BE SOH
;        
RHNTO:	CB	R2,@SOH
	JEQ	GOT_SOH
	CB	R2,@EOT
	JEQ	GOT_EOT

;
;  WE DIDN'T RECEIVE SOH
;
	JMP	RECV_SECT_ERR
;
; WE HAVE SOH NOW SO BEGIN RECEIVING RECORD OF DATA
;
GOT_SOH:
	LI	R1,16		;ZERO WAIT TIME
	CALL	@RECV_WAIT		;GET RECORD NUMBER
	MOVB	R2,@RECVD_SECT_NO	;
	CLR	R1		;ZERO WAIT TIME
	CALL	@RECV_WAIT		;GET INVERTED RECORD NUMBER
	MOVB	R2,@COMP_REC_NO
;
; NOW GET 128 BYTES OF DATA
;
	LI	R6,RECSIZE		;BLOCK SIZE
	CLR	R5		;CHECKSUM

NEXT_CHR:
	LI	R1,16		;NOMINAL WAIT TIME
 	CALL	@RECV_WAIT
	MOVB	R2,*R4+			;UPDATE THE RECORD POINTER
	AB	R2,R5			;UPDATE THE CHECKSUM
	DEC	R6			;COUNT DOWN THE NUMBER OF BYTES
	JNE	NEXT_CHR
;
; WAIT FOR CHECKSUM TO BE RECEIVED
;
	LI	R1,16		;NOMINAL WAIT TIME
	CALL	@RECV_WAIT		;GET CHECKSUM INTO R2
	MOVB	R2,@CHECKSUM
	AI	R4,-RECSIZE		;ASSUME ERROR SO BACK UP POINTER

;
; CHECK WE HAVE CONSISTENT RECORD NUMBERS AND CHECKSUMS BETWEEN
; BOTH SENDER AND RECEIVER
;
	MOVB	@RECVD_SECT_NO,R0
	INV	R0			;INVERT RECORD 1
	CB	R0,@COMP_REC_NO		;INVERTED VALUE OF RECVD SECT NUMBER
	JNE	RECV_SECT_ERR		;BAD RECORD SO TRY AGAIN
	CB	R2,R5			;CHECKSUMS MATCH ?
	JNE	RECV_SECT_ERR		;CHECKSUMS DON'T MATCH SO TRY AGAIN

;-----------------------------------------------
;Got a good block. See if we've already received
;this block. (It might be a retransmission.) If
;it's the most recently received block, then try
;again - otherwise it's an error.
;-----------------------------------------------
;
; WE HAVE GOT A SECTOR KEEP IT IF IT IS EQUAL = 1 + PREV SECTOR.
; IF DUPLICATE KEEP THE LATEST
;
	MOVB	@RECVD_SECT_NO,R1 		;RECEIVED SECTOR NUMBER
	MOVB	@SECTNO,R0			;GET PREVIOUS SECTOR NUMBER
	CB	R1,R0			;SENDER HAS RESENT THE SAME SECTOR SO PROBABLY MISSED THE ACK, SO RESEND
	JEQ	DO_ACK
;	JL	RCV_SEQ_ERROR		;IF LESS WE MAY BE ABLE TO RECOVER USING ACK
	AI	R0,1*256			;CALCULATE WHAT SHOULD BE THE NEXT RECORD NUMBER (ADD ONE)
	CB	R1,R0			;IF EQUAL THEN THAT IS WHAT WE EXPECTED
	JEQ	GOT_RECORD			;MATCH IF SO GOOD AND IN SEQUENCE
	JMP	RCV_SEQ_ERROR		;FATAL ERROR AS WE HAVE LOST A RECORD AND CANNOT RECO	
;	JMP	DO_ACK			;WE MIGHT BE ABLE TO RECOVER TO CURRENT POSITION BY SENDING ACKS
;
;ACKNOWLEDGE A GOOD SECTOR AND LOOK FOR NEXT
;
DO_ACK:
 	MOVB	@ACK,R2
	CALL	@TX
	B	@RECV_LOOP

;
; CHECK FOR FILE NUMBERING ERROR 
;
RCV_SEQ_ERROR:
	JMP	SEQUENCE_ERROR					  
;
GOT_RECORD:
	MOVB	@RECVD_SECT_NO,@SECTNO	;UPDATE SECTOR NUMBER
;
; WE HAVE A NEW RECORDS HERE SO WRITE THEM TO DISC
;	
;
	AI	R4,RECSIZE		;BUMP BUFFER POINTER NOW RECORD IS VALID
	DEC	@REC_COUNT
	JNE	DO_ACK
	CALL	@WRITE_SECTOR	;WE HAVE RECEIVED TWO RECORDS SO WRITE TO DISC
	LI	R4,SECTOR_BUFFER	;RESET THE BUFFER POINTER
	INCT	@REC_COUNT		;BUMP THE RECORD COUNT BACK UP TO 4
	INCT	@REC_COUNT
	JMP	DO_ACK
;
RETRY:	WORD	0
;
; TRY TO ABORT AND ERROR MESSAGE IS POINTED TO BY R3
;


SEQUENCE_ERROR:
	LI	R0,SEQ_ERROR_MSG
	JMP	LOAD_END

SECTOR_ERROR:
	LI	R0,SECT_ERROR_MSG
	JMP	LOAD_END

WRITE_ERROR:
	LI	R0,WRITE_MESSAGE
	JMP	LOAD_END
;
;**************************************************************
;
;	TRY TO TERMINATE THE TRANSFER.  ALSO DELETE THE FILE
;
;***************************************************************
;
LOAD_END:	MOV	R0,@ERR_MSG_ADDR
;
	MOVB	@CAN,R2		;CANCEL THE TRANSFER
	CALL	@TX

LE_1:	LI	R1,64
	CALL	@RECV_WAIT
	CB	R2,@REC_TIME_OUT	;TIMEOUT ERROR ?
	JNE	LE_1

	LI	R2,ERAFIL 		;PURGE IF AN ERROR
	LI	R3,FCB
	CALL	@BDOS
	MESG	@ERR_MSG_ADDR
	B	@SHELL

GOT_EOT:
	MOVB	@ACK,R2
	CALL	@TX		;SEND ACK RESPONSE
 	RET
;
;RX WAIT - CAN TEST FOR TIMEOUT.  TIMEOUT MULTIPLIER IS IN R1
;
RECV_WAIT:
	SLA	R1,8	        	;TIME OUT FIGURE
SWAIT1:	CALL	@RXSTAT
	JNE	RX		;GO GET CHAR AND RETURN
	DEC	R1
	JNE	SWAIT1
	SETO	R2		;SHOW  TIMEOUT ERROR
	RET
;
;	READ CHARACTER STATUS
;
RXSTAT:	CLR	R0		;0-> not ready
	LI	R12,80H
	TB	21		;RECEIVE BUFFER REG FULL ?
	JNE	RX2		;NO
	INC	R0		;YES
RX2:	MOV	R0,R0		;SET FLAGS
	RET

; Receive a char in R2 no status checking
RX_FLUSH:
	CLR	R0
	LI	R12,80H
RX3	TB	21		;RECEIVE BUFFER REG FULL ?  GET RID OF JUNK
	JEQ	RX3		;NO
	STCR	R2,8
	SBZ	18		;SHOW WE RECEIVED CHARACTER
	MOV	R0,R0		;SET FLAGS
	RET

; Receive a char in R2 no status checking
RX:	CLR	R2
	LI	R12,80H
	STCR	R2,8
	SBZ	18		;SHOW WE RECEIVED CHARACTER
	RET

;
WAIT	SETO	R0
WAIT_2	DEC	R0
	JNE	WAIT_2
	RET
;
; TX A CHAR
;
TX	LI	R1,5000
	LI	R12,80H
TX2	CALL	@TXSTAT
	JNE	TX3
	DEC	R1
	JNE	TX2		
	RET			;RETURN WITH ZERO IF TIMEOUT
TX3	SBO	16		;TURN ON THE TRANSMITTER
	LDCR	R2,8
	SBZ	16		;TURN OFF TRANSMITTER
	RET

; TX STATUS
;
TXSTAT	CLR	R0		;0-> not ready
	LI	R12,80H
	SBO	16		;TURN ON THE TRANSMITTER
TX_STAT1
	TB	22		;WAIT FOR XBRE =1
	JNE	TX_STAT1
	SBZ	16		;TURN OFF TRANSMITTER
	INC	R0	
	MOV	R0,R0		;set flags
	RET

;
;	BUFFER AND STACK AREA ETC, BLOCK STARTED FOR SYMBOL
;
FCB:		BSS	36
LINPTR:		WORD	0
BUFFER_POINTER:	WORD	SECTOR_BUFFER

SECTOR_BUFFER:	BSS	BYTSEC
		WORD	1234H
WORKSP:		BSS	32
		BSS	32		;ALLOCATE STACK
STACKP:		EQU	$-2
		EVEN
	END
